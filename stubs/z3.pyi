#  pylint: disable=unused-argument,invalid-name,no-self-use
from typing import Iterable, Optional

class Context: ...

class IntNumRef:
    def as_long(self) -> int: ...

class FuncDeclRef:
    def name(self) -> str: ...

class ExprRef:
    def __eq__(self, other: "ExprRef") -> "BoolRef": ...  # type: ignore
    def __ne__(self, other: "ExprRef") -> "BoolRef": ...  # type: ignore
    def arg(self, idx: int) -> "ExprRef": ...
    def num_args(self) -> int: ...
    def decl(self) -> FuncDeclRef: ...

class BoolRef(ExprRef): ...

class ArithRef(ExprRef):
    def __sub__(self, other: "ArithRef") -> "ArithRef": ...
    def __add__(self, other: "ArithRef") -> "ArithRef": ...
    def __mul__(self, other: "ArithRef") -> "ArithRef": ...
    def __pow__(self, other: "ArithRef") -> "ArithRef": ...
    def __mod__(self, other: "ArithRef") -> "ArithRef": ...
    def __truediv__(self, other: "ArithRef") -> "ArithRef": ...
    def __gt__(self, other: "ArithRef") -> BoolRef: ...
    def __ge__(self, other: "ArithRef") -> BoolRef: ...
    def __lt__(self, other: "ArithRef") -> BoolRef: ...
    def __le__(self, other: "ArithRef") -> BoolRef: ...
    def __neg__(self) -> "ArithRef": ...

def Int(name: str, ctx: Optional[Context] = None) -> ArithRef: ...
def IntVal(val: int, ctx: Optional[Context] = None) -> ArithRef: ...
def Sum(*vals: ArithRef, ctx: Optional[Context] = None) -> ArithRef: ...
def Product(*vals: ArithRef, ctx: Optional[Context] = None) -> ArithRef: ...
def Bool(name: str, ctx: Optional[Context] = None) -> BoolRef: ...
def BoolVal(val: bool, ctx: Optional[Context] = None) -> BoolRef: ...
def Not(val: BoolRef, ctx: Optional[Context] = None) -> BoolRef: ...
def And(*args: BoolRef) -> BoolRef: ...
def Or(*args: BoolRef) -> BoolRef: ...
def If(c: BoolRef, t: ExprRef, e: ExprRef, ctx: Optional[Context] = None) -> ExprRef: ...
def ForAll(v: Iterable[ExprRef], cond: ExprRef) -> ExprRef: ...
def Exists(v: Iterable[ExprRef], cond: ExprRef) -> ExprRef: ...
def simplify(e: ExprRef) -> ExprRef: ...
def is_distinct(e: ExprRef) -> bool: ...
def is_add(e: ArithRef) -> bool: ...
def is_sub(e: ArithRef) -> bool: ...
def is_mul(e: ArithRef) -> bool: ...
def is_idiv(e: ArithRef) -> bool: ...
def is_mod(e: ArithRef) -> bool: ...
def is_const(e: ArithRef) -> bool: ...
def is_true(e: BoolRef) -> bool: ...
def is_false(e: BoolRef) -> bool: ...
def is_not(e: BoolRef) -> bool: ...
def is_and(e: BoolRef) -> bool: ...
def is_or(e: BoolRef) -> bool: ...
def is_lt(e: BoolRef) -> bool: ...
def is_le(e: BoolRef) -> bool: ...
def is_eq(e: BoolRef) -> bool: ...
def is_ge(e: BoolRef) -> bool: ...
def is_gt(e: BoolRef) -> bool: ...

class CheckSatResult: ...

sat = CheckSatResult()
unsat = CheckSatResult()
unknown = CheckSatResult()

class Solver:
    def add(self, *expr: ExprRef) -> None: ...
    def check(self, *asns: ExprRef) -> CheckSatResult: ...
    def assert_and_track(self, expr: ExprRef, name: str) -> None: ...
    def unsat_core(self) -> Iterable[ExprRef]: ...
    def set(self, unsat_core: bool) -> None: ...
